{
  "version": 3,
  "sources": ["../../../../../../node_modules/@softarc/native-federation-runtime/fesm2022/softarc-native-federation-runtime.mjs"],
  "sourcesContent": ["const defaultShareOptions = {\n    singleton: false,\n    requiredVersionPrefix: '',\n};\nfunction getShared(options = defaultShareOptions) {\n    const nfc = window;\n    const externals = nfc.__NATIVE_FEDERATION__.externals;\n    const shared = {};\n    const allKeys = [...externals.keys()];\n    const keys = allKeys\n        .filter((k) => !k.startsWith('/@id/') &&\n        !k.startsWith('@angular-architects/module-federation') &&\n        !k.endsWith('@'))\n        .sort();\n    for (const key of keys) {\n        const idx = key.lastIndexOf('@');\n        const pkgName = key.substring(0, idx);\n        const version = key.substring(idx + 1);\n        const path = externals.get(key) ?? '';\n        const shareObj = {\n            version,\n            get: async () => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const lib = await window.importShim(path);\n                return () => lib;\n            },\n            shareConfig: {\n                singleton: options.singleton,\n                requiredVersion: options.requiredVersionPrefix + version,\n            },\n        };\n        if (!shared[pkgName]) {\n            shared[pkgName] = [];\n        }\n        shared[pkgName].push(shareObj);\n    }\n    return shared;\n}\n\nconst nfNamespace = '__NATIVE_FEDERATION__';\nconst global$1 = globalThis;\nglobal$1[nfNamespace] ??= {\n    externals: new Map(),\n    remoteNamesToRemote: new Map(),\n    baseUrlToRemoteNames: new Map(),\n};\nconst globalCache = global$1[nfNamespace];\n\nconst externals = globalCache.externals;\nfunction getExternalKey(shared) {\n    return `${shared.packageName}@${shared.version}`;\n}\nfunction getExternalUrl(shared) {\n    const packageKey = getExternalKey(shared);\n    return externals.get(packageKey);\n}\nfunction setExternalUrl(shared, url) {\n    const packageKey = getExternalKey(shared);\n    externals.set(packageKey, url);\n}\n\nfunction mergeImportMaps(map1, map2) {\n    return {\n        imports: { ...map1.imports, ...map2.imports },\n        scopes: { ...map1.scopes, ...map2.scopes },\n    };\n}\n\nconst remoteNamesToRemote = globalCache.remoteNamesToRemote;\nconst baseUrlToRemoteNames = globalCache.baseUrlToRemoteNames;\nfunction addRemote(remoteName, remote) {\n    remoteNamesToRemote.set(remoteName, remote);\n    baseUrlToRemoteNames.set(remote.baseUrl, remoteName);\n}\nfunction getRemoteNameByBaseUrl(baseUrl) {\n    return baseUrlToRemoteNames.get(baseUrl);\n}\nfunction isRemoteInitialized(baseUrl) {\n    return baseUrlToRemoteNames.has(baseUrl);\n}\nfunction getRemote(remoteName) {\n    return remoteNamesToRemote.get(remoteName);\n}\nfunction hasRemote(remoteName) {\n    return remoteNamesToRemote.has(remoteName);\n}\n\nconst global = globalThis;\nlet policy;\nfunction createPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (global.trustedTypes) {\n            try {\n                policy = global.trustedTypes.createPolicy('native-federation', {\n                    createHTML: (html) => html,\n                    createScript: (script) => script,\n                    createScriptURL: (url) => url,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy may throw an exception if called with a name that is already registered, even in report-only mode.\n            }\n        }\n    }\n    return policy;\n}\nfunction tryCreateTrustedScript(script) {\n    return createPolicy()?.createScript(script) ?? script;\n}\n\nfunction appendImportMap(importMap) {\n    document.head.appendChild(Object.assign(document.createElement('script'), {\n        type: tryCreateTrustedScript('importmap-shim'),\n        textContent: tryCreateTrustedScript(JSON.stringify(importMap)),\n    }));\n}\n\n/**\n * Returns the full directory of a given path.\n * @param url - The path to get the directory of.\n * @returns The full directory of the path.\n */\nfunction getDirectory(url) {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n/**\n * Joins two paths together taking into account trailing slashes and \"./\" prefixes.\n * @param path1 - The first path to join.\n * @param path2 - The second path to join.\n * @returns The joined path.\n */\nfunction joinPaths(path1, path2) {\n    while (path1.endsWith('/')) {\n        path1 = path1.substring(0, path1.length - 1);\n    }\n    if (path2.startsWith('./')) {\n        path2 = path2.substring(2, path2.length);\n    }\n    return `${path1}/${path2}`;\n}\n\nconst BUILD_NOTIFICATIONS_ENDPOINT = '/@angular-architects/native-federation:build-notifications';\nvar BuildNotificationType;\n(function (BuildNotificationType) {\n    BuildNotificationType[\"COMPLETED\"] = \"federation-rebuild-complete\";\n    BuildNotificationType[\"ERROR\"] = \"federation-rebuild-error\";\n    BuildNotificationType[\"CANCELLED\"] = \"federation-rebuild-cancelled\";\n})(BuildNotificationType || (BuildNotificationType = {}));\n\n/**\n * Watches for federation build completion events and automatically reloads the page.\n *\n * This function establishes a Server-Sent Events (SSE) connection to listen for\n * 'federation-rebuild-complete' notifications. When a build completes successfully,\n * it triggers a page reload to reflect the latest changes.\n * @param endpoint - The SSE endpoint URL to watch for build notifications.\n */\nfunction watchFederationBuildCompletion(endpoint) {\n    const eventSource = new EventSource(endpoint);\n    eventSource.onmessage = function (event) {\n        const data = JSON.parse(event.data);\n        if (data.type === BuildNotificationType.COMPLETED) {\n            console.log('[Federation] Rebuild completed, reloading...');\n            window.location.reload();\n        }\n    };\n    eventSource.onerror = function (event) {\n        console.warn('[Federation] SSE connection error:', event);\n    };\n}\n\n/**\n * Initializes the Native Federation runtime for the host application.\n *\n * This is the main entry point for setting up federation. It performs the following:\n * 1. Loads the host's remoteEntry.json to discover shared dependencies\n * 2. Loads each remote's remoteEntry.json to discover exposed modules\n * 3. Creates an ES Module import map with proper scoping\n * 4. Injects the import map into the DOM as a <script type=\"importmap-shim\">\n *\n * The import map allows dynamic imports to resolve correctly:\n * - Host shared deps go in root imports (e.g., \"angular\": \"./angular.js\")\n * - Remote exposed modules go in root imports (e.g., \"mfe1/Component\": \"http://...\")\n * - Remote shared deps go in scoped imports for proper resolution\n *\n * @param remotesOrManifestUrl - Either:\n *   - A record of remote names to their remoteEntry.json URLs\n *     Example: { mfe1: 'http://localhost:3000/remoteEntry.json' }\n *   - A URL to a manifest.json that contains the remotes record\n *     Example: 'http://localhost:3000/federation-manifest.json'\n *\n * @param options - Configuration options:\n *   - cacheTag: A version string to append as query param for cache busting\n *     Example: { cacheTag: 'v1.0.0' } results in '?t=v1.0.0' on all requests\n *\n * @returns The final merged ImportMap that was injected into the DOM\n *\n */\nasync function initFederation(remotesOrManifestUrl = {}, options) {\n    const cacheTag = options?.cacheTag ? `?t=${options.cacheTag}` : '';\n    const normalizedRemotes = typeof remotesOrManifestUrl === 'string'\n        ? await loadManifest(remotesOrManifestUrl + cacheTag)\n        : remotesOrManifestUrl;\n    const hostInfo = await loadFederationInfo(`./remoteEntry.json${cacheTag}`);\n    const hostImportMap = await processHostInfo(hostInfo);\n    // Host application is fully loaded, now we can process the remotes\n    // Each remote contributes:\n    // - Exposed modules to root imports\n    // - Shared dependencies to scoped imports\n    const remotesImportMap = await processRemoteInfos(normalizedRemotes, {\n        throwIfRemoteNotFound: false,\n        ...options,\n    });\n    const mergedImportMap = mergeImportMaps(hostImportMap, remotesImportMap);\n    // Inject the final import map into the DOM with importmap-shim\n    appendImportMap(mergedImportMap);\n    return mergedImportMap;\n}\n/**\n * Loads a federation manifest file (JSON) from the given URL.\n *\n * The manifest should map remote names to their remoteEntry.json URLs.\n *\n * @param manifestUrl - The URL to the manifest.json file.\n * @returns A promise resolving to an object mapping remote names to their remoteEntry.json URLs.\n */\nasync function loadManifest(manifestUrl) {\n    const manifest = (await fetch(manifestUrl).then((r) => r.json()));\n    return manifest;\n}\n/**\n * Adds cache busting query parameter to a URL if cacheTag is provided.\n */\nfunction applyCacheTag(url, cacheTag) {\n    if (!cacheTag)\n        return url;\n    const separator = url.includes('?') ? '&' : '?';\n    return `${url}${separator}t=${cacheTag}`;\n}\n/**\n * Handles errors when loading a remote entry.\n * Either throws or logs based on options.\n */\nfunction handleRemoteLoadError(remoteName, remoteUrl, options, originalError) {\n    const errorMessage = `Error loading remote entry for ${remoteName} from file ${remoteUrl}`;\n    if (options.throwIfRemoteNotFound) {\n        throw new Error(errorMessage);\n    }\n    console.error(errorMessage);\n    console.error(originalError);\n    return null;\n}\n/**\n * Fetches and registers multiple remote applications in parallel and merges their import maps.\n *\n * This function is the orchestrator for loading all remotes. It:\n * 1. Creates a promise for each remote to load its remoteEntry.json\n * 2. Applies cache busting to each remote URL\n * 3. Handles errors gracefully (logs or throws based on options)\n * 4. Merges all successful remote import maps into one\n *\n * Each remote contributes:\n * - Its exposed modules to the root imports\n * - Its shared dependencies to scoped imports\n *\n * @param remotes - Record of remote names to their remoteEntry.json URLs\n * @param options - Processing options including:\n *   - throwIfRemoteNotFound: Whether to throw or log on remote load failure\n *   - cacheTag: Cache busting tag to append to URLs\n *\n * @returns Merged import map containing all remotes' contributions\n *\n */\nasync function processRemoteInfos(remotes, options = { throwIfRemoteNotFound: false }) {\n    // Each promise will independently fetch and process its remoteEntry.json\n    const fetchAndRegisterRemotePromises = Object.entries(remotes).map(async ([remoteName, remoteUrl]) => {\n        try {\n            const urlWithCache = applyCacheTag(remoteUrl, options.cacheTag);\n            return await fetchAndRegisterRemote(urlWithCache, remoteName);\n        }\n        catch (e) {\n            return handleRemoteLoadError(remoteName, remoteUrl, options, e);\n        }\n    });\n    const remoteImportMaps = await Promise.all(fetchAndRegisterRemotePromises);\n    // Filter out failed remotes (null values) and merge successful ones\n    const importMap = remoteImportMaps.reduce((acc, remoteImportMap) => remoteImportMap ? mergeImportMaps(acc, remoteImportMap) : acc, { imports: {}, scopes: {} });\n    return importMap;\n}\n/**\n * Fetches a single remote application's remoteEntry.json file and registers it in the system (global registry).\n *\n * This function handles everything needed to integrate one remote:\n * 1. Fetches the remote's remoteEntry.json file\n * 2. Extracts the base URL from the remoteEntry path\n * 3. Creates import map entries for exposed modules and shared deps\n * 4. Registers the remote in the global remotes registry\n * 5. Sets up hot reload watching if configured (development mode)\n *\n * @param federationInfoUrl - Full URL to the remote's remoteEntry.json\n * @param remoteName - Name to use for this remote (optional, uses info.name if not provided)\n *\n * @returns Import map containing this remote's exposed modules and shared dependencies\n *\n * @example\n * ```typescript\n * const importMap = await fetchAndRegisterRemote(\n *   'http://localhost:3000/mfe1/remoteEntry.json',\n *   'mfe1'\n * );\n * // Result: {\n * //   imports: { 'mfe1/Component': 'http://localhost:3000/mfe1/Component.js' },\n * //   scopes: { 'http://localhost:3000/mfe1/': { 'lodash': '...' } }\n * // }\n * ```\n */\nasync function fetchAndRegisterRemote(federationInfoUrl, remoteName) {\n    const baseUrl = getDirectory(federationInfoUrl);\n    const remoteInfo = await loadFederationInfo(federationInfoUrl);\n    // Uses the name from the remote's remoteEntry.json if not explicitly provided\n    if (!remoteName) {\n        remoteName = remoteInfo.name;\n    }\n    // Setup hot reload watching for development mode and in case it has a build notifications endpoint\n    if (remoteInfo.buildNotificationsEndpoint) {\n        watchFederationBuildCompletion(baseUrl + remoteInfo.buildNotificationsEndpoint);\n    }\n    const importMap = createRemoteImportMap(remoteInfo, remoteName, baseUrl);\n    // Register this remote in the global registry\n    addRemote(remoteName, { ...remoteInfo, baseUrl });\n    return importMap;\n}\n/**\n * Creates an import map for a remote application.\n *\n * The import map has two parts:\n * 1. Imports (root level): Maps remote's exposed modules\n *    Example: \"mfe1/Component\" -> \"http://localhost:3000/mfe1/Component.js\"\n *\n * 2. Scopes: Maps remote's shared dependencies within its scope\n *    Example: \"http://localhost:3000/mfe1/\": { \"lodash\": \"http://localhost:3000/mfe1/lodash.js\" }\n *\n * Scoping ensures that when a module from this remote imports 'lodash',\n * it gets the version from this remote's bundle, not another version.\n *\n * @param remoteInfo - Federation info from the remote's remoteEntry.json\n * @param remoteName - Name used to prefix exposed module keys\n * @param baseUrl - Base URL where the remote is hosted\n *\n * @returns Import map with imports and scopes for this remote\n */\nfunction createRemoteImportMap(remoteInfo, remoteName, baseUrl) {\n    const imports = processExposed(remoteInfo, remoteName, baseUrl);\n    const scopes = processRemoteImports(remoteInfo, baseUrl);\n    return { imports, scopes };\n}\n/**\n * Fetches and parses a remoteEntry.json file.\n *\n * The remoteEntry.json contains metadata about a federated module:\n * - name: The application name\n * - exposes: Array of modules this app exposes to others\n * - shared: Array of dependencies this app shares\n * - buildNotificationsEndpoint: Optional SSE endpoint for hot reload (development mode)\n *\n * @param remoteEntryUrl - URL to the remoteEntry.json file (can be relative or absolute)\n * @returns Parsed federation info object\n */\nasync function loadFederationInfo(remoteEntryUrl) {\n    const info = (await fetch(remoteEntryUrl).then((r) => r.json()));\n    return info;\n}\n/**\n * Processes a remote's shared dependencies into scoped import map entries.\n *\n * Shared dependencies need to be scoped to avoid version conflicts.\n * When a module from \"http://localhost:3000/mfe1/\" imports \"lodash\",\n * the import map scope ensures it gets the correct version.\n *\n * Scope structure:\n * {\n *   \"http://localhost:3000/mfe1/\": {\n *     \"lodash\": \"http://localhost:3000/mfe1/lodash.js\",\n *     \"rxjs\": \"http://localhost:3000/mfe1/rxjs.js\"\n *   }\n * }\n *\n * This function also manages external URLs - if a shared dependency\n * has already been loaded from another location, it can reuse that URL.\n *\n * @param remoteInfo - Federation info containing shared dependencies\n * @param baseUrl - Base URL of the remote (used as the scope key)\n *\n * @returns Scopes object mapping baseUrl to its shared dependencies\n */\nfunction processRemoteImports(remoteInfo, baseUrl) {\n    const scopes = {};\n    const scopedImports = {};\n    for (const shared of remoteInfo.shared) {\n        // Check if this dependency already has an external URL registered\n        // If not, construct the URL from the base path and output filename\n        const outFileName = getExternalUrl(shared) ?? joinPaths(baseUrl, shared.outFileName);\n        // Register this URL as the external location for this shared dependency\n        // This allows other remotes to potentially reuse this version\n        setExternalUrl(shared, outFileName);\n        // Add to the scoped imports: package name -> full URL\n        scopedImports[shared.packageName] = outFileName;\n    }\n    scopes[baseUrl + '/'] = scopedImports;\n    return scopes;\n}\n/**\n * Processes a remote's exposed modules into root-level import map entries.\n *\n * Exposed modules are what the remote makes available to other applications.\n * They go in the root imports (not scoped) so any app can import them.\n *\n * Example exposed module:\n * - Remote 'mfe1' exposes './Component' from file 'Component.js'\n * - Results in: \"mfe1/Component\" -> \"http://localhost:3000/mfe1/Component.js\"\n *\n * This allows other apps to do:\n * ```typescript\n * import { Component } from 'mfe1/Component';\n * ```\n *\n * @param remoteInfo - Federation info containing exposed modules\n * @param remoteName - Name to prefix the exposed keys with\n * @param baseUrl - Base URL where the remote's files are hosted\n *\n * @returns Imports object mapping remote module keys to their URLs\n */\nfunction processExposed(remoteInfo, remoteName, baseUrl) {\n    const imports = {};\n    for (const exposed of remoteInfo.exposes) {\n        // Create the import key by joining remote name with the exposed key\n        // Example: 'mfe1' + './Component' -> 'mfe1/Component'\n        const key = joinPaths(remoteName, exposed.key);\n        // Create the full URL to the exposed module's output file\n        // Example: 'http://localhost:3000/mfe1' + 'Component.js' -> 'http://localhost:3000/mfe1/Component.js'\n        const value = joinPaths(baseUrl, exposed.outFileName);\n        imports[key] = value;\n    }\n    return imports;\n}\n/**\n * Processes the host application's federation info into an import map.\n *\n * The host app typically doesn't expose modules (it's the consumer),\n * but it does share dependencies that should be available to remotes.\n *\n * Host shared dependencies go in root-level imports (not scoped) because:\n * 1. The host loads first and establishes the base environment\n * 2. Remotes should prefer host versions to avoid duplication\n *\n * @param hostInfo - Federation info from the host's remoteEntry.json\n * @param relBundlesPath - Relative path to the host's bundle directory (default: './')\n *\n * @returns Import map with host's shared dependencies in root imports\n */\nasync function processHostInfo(hostInfo, relBundlesPath = './') {\n    // Transform shared array into imports object\n    const imports = hostInfo.shared.reduce((acc, cur) => ({\n        ...acc,\n        [cur.packageName]: relBundlesPath + cur.outFileName,\n    }), {});\n    // Register external URLs for host's shared dependencies\n    // This allows remotes to discover and potentially reuse these versions\n    for (const shared of hostInfo.shared) {\n        setExternalUrl(shared, relBundlesPath + shared.outFileName);\n    }\n    // Host doesn't have scopes - its shared deps are at root level\n    return { imports, scopes: {} };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\n    const options = normalizeOptions(optionsOrRemoteName, exposedModule);\n    await ensureRemoteInitialized(options);\n    const remoteName = getRemoteNameByOptions(options);\n    const remote = getRemote(remoteName);\n    const fallback = options.fallback;\n    // Handles errors when the remote is missing\n    const remoteError = !remote ? 'unknown remote ' + remoteName : '';\n    if (!remote && !fallback)\n        throw new Error(remoteError);\n    if (!remote) {\n        logClientError(remoteError);\n        return Promise.resolve(fallback);\n    }\n    const exposedModuleInfo = remote.exposes.find((e) => e.key === options.exposedModule);\n    // Handles errors when the exposed module is missing\n    const exposedError = !exposedModuleInfo\n        ? `Unknown exposed module ${options.exposedModule} in remote ${remoteName}`\n        : '';\n    if (!exposedModuleInfo && !fallback)\n        throw new Error(exposedError);\n    if (!exposedModuleInfo) {\n        logClientError(exposedError);\n        return Promise.resolve(fallback);\n    }\n    const moduleUrl = joinPaths(remote.baseUrl, exposedModuleInfo.outFileName);\n    try {\n        const module = _import(moduleUrl);\n        return module;\n    }\n    catch (e) {\n        // Handles errors when the module import fails\n        if (fallback) {\n            console.error('error loading remote module', e);\n            return fallback;\n        }\n        throw e;\n    }\n}\n/**\n * Internal helper function to perform the dynamic import.\n *\n * @template T - The expected type of the module's exports\n * @param moduleUrl - Full URL to the module file to import\n * @returns Promise resolving to the imported module\n */\nfunction _import(moduleUrl) {\n    return typeof importShim !== 'undefined'\n        ? importShim(moduleUrl)\n        : import(/* @vite-ignore */ moduleUrl);\n}\n/**\n * Resolves the remote name from the provided options.\n *\n * The remote name can be determined in two ways:\n * 1. If options.remoteName is provided, use it directly\n * 2. If only remoteEntry is provided, extract the baseUrl\n *    and look up the remote name from the registry using that baseUrl\n *\n * @param options - Load options containing remoteName and/or remoteEntry\n * @returns The resolved remote name\n *\n * @throws Error if neither remoteName nor remoteEntry is provided\n * @throws Error if the remote name cannot be determined\n */\nfunction getRemoteNameByOptions(options) {\n    let remoteName;\n    if (options.remoteName) {\n        remoteName = options.remoteName;\n    }\n    else if (options.remoteEntry) {\n        const baseUrl = getDirectory(options.remoteEntry);\n        remoteName = getRemoteNameByBaseUrl(baseUrl);\n    }\n    else {\n        throw new Error('unexpected arguments: Please pass remoteName or remoteEntry');\n    }\n    if (!remoteName) {\n        throw new Error('unknown remoteName ' + remoteName);\n    }\n    return remoteName;\n}\n/**\n * Ensures that the remote is initialized before attempting to load a module from it.\n *\n * This function enables lazy-loading of remotes that weren't registered during\n * the initial `initFederation()` call. It checks if:\n * 1. A remoteEntry URL is provided in the options\n * 2. The remote at that URL hasn't been initialized yet\n *\n * If both conditions are true, it:\n * 1. Fetches the remote's remoteEntry.json file\n * 2. Registers the remote in the global registry\n * 3. Creates and appends the remote's import map to the DOM\n *\n * @param options - Load options containing optional remoteEntry URL\n * @returns Promise that resolves when the remote is initialized (or immediately if already initialized)\n *\n */\nasync function ensureRemoteInitialized(options) {\n    if (options.remoteEntry &&\n        !isRemoteInitialized(getDirectory(options.remoteEntry))) {\n        const importMap = await fetchAndRegisterRemote(options.remoteEntry);\n        appendImportMap(importMap);\n    }\n}\n/**\n * Normalizes the function arguments into a standard LoadRemoteModuleOptions object.\n *\n * The function detects which pattern is being used and converts it to the\n * standard options object format for consistent internal processing.\n *\n * @param optionsOrRemoteName - Either an options object or the remote name string\n * @param exposedModule - The exposed module key\n * @returns Normalized options object\n *\n * @throws Error if arguments don't match either supported pattern\n */\nfunction normalizeOptions(optionsOrRemoteName, exposedModule) {\n    let options;\n    if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n        options = {\n            remoteName: optionsOrRemoteName,\n            exposedModule,\n        };\n    }\n    else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n        options = optionsOrRemoteName;\n    }\n    else {\n        throw new Error('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n    return options;\n}\n/**\n * Logs an error message to the console, but only in browser environments.\n *\n * @param error - The error message to log\n *\n */\nfunction logClientError(error) {\n    if (typeof window !== 'undefined') {\n        console.error(error);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BUILD_NOTIFICATIONS_ENDPOINT, BuildNotificationType, fetchAndRegisterRemote, getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfos };\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA,IAAM,sBAAsB;AAAA,EACxB,WAAW;AAAA,EACX,uBAAuB;AAC3B;AACA,SAAS,UAAU,UAAU,qBAAqB;AAC9C,QAAM,MAAM;AACZ,QAAMA,aAAY,IAAI,sBAAsB;AAC5C,QAAM,SAAS,CAAC;AAChB,QAAM,UAAU,CAAC,GAAGA,WAAU,KAAK,CAAC;AACpC,QAAM,OAAO,QACR,OAAO,CAAC,MAAM,CAAC,EAAE,WAAW,OAAO,KACpC,CAAC,EAAE,WAAW,uCAAuC,KACrD,CAAC,EAAE,SAAS,GAAG,CAAC,EACf,KAAK;AACV,aAAW,OAAO,MAAM;AACpB,UAAM,MAAM,IAAI,YAAY,GAAG;AAC/B,UAAM,UAAU,IAAI,UAAU,GAAG,GAAG;AACpC,UAAM,UAAU,IAAI,UAAU,MAAM,CAAC;AACrC,UAAM,OAAOA,WAAU,IAAI,GAAG,KAAK;AACnC,UAAM,WAAW;AAAA,MACb;AAAA,MACA,KAAK,YAAY;AAEb,cAAM,MAAM,MAAM,OAAO,WAAW,IAAI;AACxC,eAAO,MAAM;AAAA,MACjB;AAAA,MACA,aAAa;AAAA,QACT,WAAW,QAAQ;AAAA,QACnB,iBAAiB,QAAQ,wBAAwB;AAAA,MACrD;AAAA,IACJ;AACA,QAAI,CAAC,OAAO,OAAO,GAAG;AAClB,aAAO,OAAO,IAAI,CAAC;AAAA,IACvB;AACA,WAAO,OAAO,EAAE,KAAK,QAAQ;AAAA,EACjC;AACA,SAAO;AACX;AAEA,IAAM,cAAc;AACpB,IAAM,WAAW;AACjB,SAAS,WAAW,MAAM;AAAA,EACtB,WAAW,oBAAI,IAAI;AAAA,EACnB,qBAAqB,oBAAI,IAAI;AAAA,EAC7B,sBAAsB,oBAAI,IAAI;AAClC;AACA,IAAM,cAAc,SAAS,WAAW;AAExC,IAAM,YAAY,YAAY;AAC9B,SAAS,eAAe,QAAQ;AAC5B,SAAO,GAAG,OAAO,WAAW,IAAI,OAAO,OAAO;AAClD;AACA,SAAS,eAAe,QAAQ;AAC5B,QAAM,aAAa,eAAe,MAAM;AACxC,SAAO,UAAU,IAAI,UAAU;AACnC;AACA,SAAS,eAAe,QAAQ,KAAK;AACjC,QAAM,aAAa,eAAe,MAAM;AACxC,YAAU,IAAI,YAAY,GAAG;AACjC;AAEA,SAAS,gBAAgB,MAAM,MAAM;AACjC,SAAO;AAAA,IACH,SAAS,kCAAK,KAAK,UAAY,KAAK;AAAA,IACpC,QAAQ,kCAAK,KAAK,SAAW,KAAK;AAAA,EACtC;AACJ;AAEA,IAAM,sBAAsB,YAAY;AACxC,IAAM,uBAAuB,YAAY;AACzC,SAAS,UAAU,YAAY,QAAQ;AACnC,sBAAoB,IAAI,YAAY,MAAM;AAC1C,uBAAqB,IAAI,OAAO,SAAS,UAAU;AACvD;AACA,SAAS,uBAAuB,SAAS;AACrC,SAAO,qBAAqB,IAAI,OAAO;AAC3C;AACA,SAAS,oBAAoB,SAAS;AAClC,SAAO,qBAAqB,IAAI,OAAO;AAC3C;AACA,SAAS,UAAU,YAAY;AAC3B,SAAO,oBAAoB,IAAI,UAAU;AAC7C;AAKA,IAAM,SAAS;AACf,IAAI;AACJ,SAAS,eAAe;AACpB,MAAI,WAAW,QAAW;AACtB,aAAS;AACT,QAAI,OAAO,cAAc;AACrB,UAAI;AACA,iBAAS,OAAO,aAAa,aAAa,qBAAqB;AAAA,UAC3D,YAAY,CAAC,SAAS;AAAA,UACtB,cAAc,CAAC,WAAW;AAAA,UAC1B,iBAAiB,CAAC,QAAQ;AAAA,QAC9B,CAAC;AAAA,MACL,QACM;AAAA,MAEN;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,uBAAuB,QAAQ;AACpC,SAAO,aAAa,GAAG,aAAa,MAAM,KAAK;AACnD;AAEA,SAAS,gBAAgB,WAAW;AAChC,WAAS,KAAK,YAAY,OAAO,OAAO,SAAS,cAAc,QAAQ,GAAG;AAAA,IACtE,MAAM,uBAAuB,gBAAgB;AAAA,IAC7C,aAAa,uBAAuB,KAAK,UAAU,SAAS,CAAC;AAAA,EACjE,CAAC,CAAC;AACN;AAOA,SAAS,aAAa,KAAK;AACvB,QAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,QAAM,IAAI;AACV,SAAO,MAAM,KAAK,GAAG;AACzB;AAOA,SAAS,UAAU,OAAO,OAAO;AAC7B,SAAO,MAAM,SAAS,GAAG,GAAG;AACxB,YAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,CAAC;AAAA,EAC/C;AACA,MAAI,MAAM,WAAW,IAAI,GAAG;AACxB,YAAQ,MAAM,UAAU,GAAG,MAAM,MAAM;AAAA,EAC3C;AACA,SAAO,GAAG,KAAK,IAAI,KAAK;AAC5B;AAEA,IAAM,+BAA+B;AACrC,IAAI;AAAA,CACH,SAAUC,wBAAuB;AAC9B,EAAAA,uBAAsB,WAAW,IAAI;AACrC,EAAAA,uBAAsB,OAAO,IAAI;AACjC,EAAAA,uBAAsB,WAAW,IAAI;AACzC,GAAG,0BAA0B,wBAAwB,CAAC,EAAE;AAUxD,SAAS,+BAA+B,UAAU;AAC9C,QAAM,cAAc,IAAI,YAAY,QAAQ;AAC5C,cAAY,YAAY,SAAU,OAAO;AACrC,UAAM,OAAO,KAAK,MAAM,MAAM,IAAI;AAClC,QAAI,KAAK,SAAS,sBAAsB,WAAW;AAC/C,cAAQ,IAAI,8CAA8C;AAC1D,aAAO,SAAS,OAAO;AAAA,IAC3B;AAAA,EACJ;AACA,cAAY,UAAU,SAAU,OAAO;AACnC,YAAQ,KAAK,sCAAsC,KAAK;AAAA,EAC5D;AACJ;AA6BA,eAAe,eAAe,uBAAuB,CAAC,GAAG,SAAS;AAC9D,QAAM,WAAW,SAAS,WAAW,MAAM,QAAQ,QAAQ,KAAK;AAChE,QAAM,oBAAoB,OAAO,yBAAyB,WACpD,MAAM,aAAa,uBAAuB,QAAQ,IAClD;AACN,QAAM,WAAW,MAAM,mBAAmB,qBAAqB,QAAQ,EAAE;AACzE,QAAM,gBAAgB,MAAM,gBAAgB,QAAQ;AAKpD,QAAM,mBAAmB,MAAM,mBAAmB,mBAAmB;AAAA,IACjE,uBAAuB;AAAA,KACpB,QACN;AACD,QAAM,kBAAkB,gBAAgB,eAAe,gBAAgB;AAEvE,kBAAgB,eAAe;AAC/B,SAAO;AACX;AASA,eAAe,aAAa,aAAa;AACrC,QAAM,WAAY,MAAM,MAAM,WAAW,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;AAC/D,SAAO;AACX;AAIA,SAAS,cAAc,KAAK,UAAU;AAClC,MAAI,CAAC;AACD,WAAO;AACX,QAAM,YAAY,IAAI,SAAS,GAAG,IAAI,MAAM;AAC5C,SAAO,GAAG,GAAG,GAAG,SAAS,KAAK,QAAQ;AAC1C;AAKA,SAAS,sBAAsB,YAAY,WAAW,SAAS,eAAe;AAC1E,QAAM,eAAe,kCAAkC,UAAU,cAAc,SAAS;AACxF,MAAI,QAAQ,uBAAuB;AAC/B,UAAM,IAAI,MAAM,YAAY;AAAA,EAChC;AACA,UAAQ,MAAM,YAAY;AAC1B,UAAQ,MAAM,aAAa;AAC3B,SAAO;AACX;AAsBA,eAAe,mBAAmB,SAAS,UAAU,EAAE,uBAAuB,MAAM,GAAG;AAEnF,QAAM,iCAAiC,OAAO,QAAQ,OAAO,EAAE,IAAI,OAAO,CAAC,YAAY,SAAS,MAAM;AAClG,QAAI;AACA,YAAM,eAAe,cAAc,WAAW,QAAQ,QAAQ;AAC9D,aAAO,MAAM,uBAAuB,cAAc,UAAU;AAAA,IAChE,SACO,GAAG;AACN,aAAO,sBAAsB,YAAY,WAAW,SAAS,CAAC;AAAA,IAClE;AAAA,EACJ,CAAC;AACD,QAAM,mBAAmB,MAAM,QAAQ,IAAI,8BAA8B;AAEzE,QAAM,YAAY,iBAAiB,OAAO,CAAC,KAAK,oBAAoB,kBAAkB,gBAAgB,KAAK,eAAe,IAAI,KAAK,EAAE,SAAS,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC;AAC9J,SAAO;AACX;AA4BA,eAAe,uBAAuB,mBAAmB,YAAY;AACjE,QAAM,UAAU,aAAa,iBAAiB;AAC9C,QAAM,aAAa,MAAM,mBAAmB,iBAAiB;AAE7D,MAAI,CAAC,YAAY;AACb,iBAAa,WAAW;AAAA,EAC5B;AAEA,MAAI,WAAW,4BAA4B;AACvC,mCAA+B,UAAU,WAAW,0BAA0B;AAAA,EAClF;AACA,QAAM,YAAY,sBAAsB,YAAY,YAAY,OAAO;AAEvE,YAAU,YAAY,iCAAK,aAAL,EAAiB,QAAQ,EAAC;AAChD,SAAO;AACX;AAoBA,SAAS,sBAAsB,YAAY,YAAY,SAAS;AAC5D,QAAM,UAAU,eAAe,YAAY,YAAY,OAAO;AAC9D,QAAM,SAAS,qBAAqB,YAAY,OAAO;AACvD,SAAO,EAAE,SAAS,OAAO;AAC7B;AAaA,eAAe,mBAAmB,gBAAgB;AAC9C,QAAM,OAAQ,MAAM,MAAM,cAAc,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;AAC9D,SAAO;AACX;AAwBA,SAAS,qBAAqB,YAAY,SAAS;AAC/C,QAAM,SAAS,CAAC;AAChB,QAAM,gBAAgB,CAAC;AACvB,aAAW,UAAU,WAAW,QAAQ;AAGpC,UAAM,cAAc,eAAe,MAAM,KAAK,UAAU,SAAS,OAAO,WAAW;AAGnF,mBAAe,QAAQ,WAAW;AAElC,kBAAc,OAAO,WAAW,IAAI;AAAA,EACxC;AACA,SAAO,UAAU,GAAG,IAAI;AACxB,SAAO;AACX;AAsBA,SAAS,eAAe,YAAY,YAAY,SAAS;AACrD,QAAM,UAAU,CAAC;AACjB,aAAW,WAAW,WAAW,SAAS;AAGtC,UAAM,MAAM,UAAU,YAAY,QAAQ,GAAG;AAG7C,UAAM,QAAQ,UAAU,SAAS,QAAQ,WAAW;AACpD,YAAQ,GAAG,IAAI;AAAA,EACnB;AACA,SAAO;AACX;AAgBA,eAAe,gBAAgB,UAAU,iBAAiB,MAAM;AAE5D,QAAM,UAAU,SAAS,OAAO,OAAO,CAAC,KAAK,QAAS,iCAC/C,MAD+C;AAAA,IAElD,CAAC,IAAI,WAAW,GAAG,iBAAiB,IAAI;AAAA,EAC5C,IAAI,CAAC,CAAC;AAGN,aAAW,UAAU,SAAS,QAAQ;AAClC,mBAAe,QAAQ,iBAAiB,OAAO,WAAW;AAAA,EAC9D;AAEA,SAAO,EAAE,SAAS,QAAQ,CAAC,EAAE;AACjC;AAGA,eAAe,iBAAiB,qBAAqB,eAAe;AAChE,QAAM,UAAU,iBAAiB,qBAAqB,aAAa;AACnE,QAAM,wBAAwB,OAAO;AACrC,QAAM,aAAa,uBAAuB,OAAO;AACjD,QAAM,SAAS,UAAU,UAAU;AACnC,QAAM,WAAW,QAAQ;AAEzB,QAAM,cAAc,CAAC,SAAS,oBAAoB,aAAa;AAC/D,MAAI,CAAC,UAAU,CAAC;AACZ,UAAM,IAAI,MAAM,WAAW;AAC/B,MAAI,CAAC,QAAQ;AACT,mBAAe,WAAW;AAC1B,WAAO,QAAQ,QAAQ,QAAQ;AAAA,EACnC;AACA,QAAM,oBAAoB,OAAO,QAAQ,KAAK,CAAC,MAAM,EAAE,QAAQ,QAAQ,aAAa;AAEpF,QAAM,eAAe,CAAC,oBAChB,0BAA0B,QAAQ,aAAa,cAAc,UAAU,KACvE;AACN,MAAI,CAAC,qBAAqB,CAAC;AACvB,UAAM,IAAI,MAAM,YAAY;AAChC,MAAI,CAAC,mBAAmB;AACpB,mBAAe,YAAY;AAC3B,WAAO,QAAQ,QAAQ,QAAQ;AAAA,EACnC;AACA,QAAM,YAAY,UAAU,OAAO,SAAS,kBAAkB,WAAW;AACzE,MAAI;AACA,UAAM,SAAS,QAAQ,SAAS;AAChC,WAAO;AAAA,EACX,SACO,GAAG;AAEN,QAAI,UAAU;AACV,cAAQ,MAAM,+BAA+B,CAAC;AAC9C,aAAO;AAAA,IACX;AACA,UAAM;AAAA,EACV;AACJ;AAQA,SAAS,QAAQ,WAAW;AACxB,SAAO,OAAO,eAAe,cACvB,WAAW,SAAS,IACpB;AAAA;AAAA,IAA0B;AAAA;AACpC;AAeA,SAAS,uBAAuB,SAAS;AACrC,MAAI;AACJ,MAAI,QAAQ,YAAY;AACpB,iBAAa,QAAQ;AAAA,EACzB,WACS,QAAQ,aAAa;AAC1B,UAAM,UAAU,aAAa,QAAQ,WAAW;AAChD,iBAAa,uBAAuB,OAAO;AAAA,EAC/C,OACK;AACD,UAAM,IAAI,MAAM,6DAA6D;AAAA,EACjF;AACA,MAAI,CAAC,YAAY;AACb,UAAM,IAAI,MAAM,wBAAwB,UAAU;AAAA,EACtD;AACA,SAAO;AACX;AAkBA,eAAe,wBAAwB,SAAS;AAC5C,MAAI,QAAQ,eACR,CAAC,oBAAoB,aAAa,QAAQ,WAAW,CAAC,GAAG;AACzD,UAAM,YAAY,MAAM,uBAAuB,QAAQ,WAAW;AAClE,oBAAgB,SAAS;AAAA,EAC7B;AACJ;AAaA,SAAS,iBAAiB,qBAAqB,eAAe;AAC1D,MAAI;AACJ,MAAI,OAAO,wBAAwB,YAAY,eAAe;AAC1D,cAAU;AAAA,MACN,YAAY;AAAA,MACZ;AAAA,IACJ;AAAA,EACJ,WACS,OAAO,wBAAwB,YAAY,CAAC,eAAe;AAChE,cAAU;AAAA,EACd,OACK;AACD,UAAM,IAAI,MAAM,8EAA8E;AAAA,EAClG;AACA,SAAO;AACX;AAOA,SAAS,eAAe,OAAO;AAC3B,MAAI,OAAO,WAAW,aAAa;AAC/B,YAAQ,MAAM,KAAK;AAAA,EACvB;AACJ;",
  "names": ["externals", "BuildNotificationType"]
}
